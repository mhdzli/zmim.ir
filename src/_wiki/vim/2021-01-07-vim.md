---
title: Vim
layout: wiki
date: 2021-01-07 08:10:47 +03:30
modified:
tags: [unix/linux, foss, vim ]
description: Vim cheat sheet.
---

# Normal Mode

{% highlight vimscript %}
. #repeat last command

z= #check avalable replacement for wrong spelled

]s #next wrong spelled

q: #enter command window

== #indent intelligently

gq{motion} #reformat (rewrap)

gqq #reformat (rewrap) current line

gu{motion} #lowercase

gU{motion} #uppercase

g~{motion} #togglecase

C-x #decrement the number at the end of the word under the cursor

C-a #increment the number at the end of the word under the cursor

gv #reselect last selection

g C-g #show current cursor position and total counts (columns, lines, words, bytes)

ga #show ASCII info for character under cursor

g8 #show UTF-8 info for character under cursor

C-w f #open the file under the cursor in a split (gf will do this without the split)

]c/[c #next/previous change/conflict
{% endhighlight %}

## Movement

{% highlight vimscript %}
h, j, k, l #per-character/per-line movement through file (left, down, up, right)

gj, gk #per-line movement through buffer, operating on display lines (which may be wrapped) not actual lines in the file (down, up)

w #forward a word (mnemonic: "word"); here "word" is an "keyword" (identifier) like "foo9" or "hgo" and the movement is to the _beginning of the next word

W #forward a "big" word; here a "word" is anything other than whitespace

b #back a word (mnemonic: "back"); again the movement is to the beginning of the word

B #back a "big" word

e #forward to the end of a word (mnemonic: "end")

E #forward to the end of a "big" word

ge #back to the end of the last word

gE #back to the end of the last "big" word

f{character} #forward to the next occurrence of character (mnemonic: "find/foward")

F{character} #same as f{character}, but search in the opposite direction

t{character} #forward til (until) the next occurrence of character (mnemonic: "til/to"); the cursor is place immediately before and not on the character

T{character} #same as t{character}, but search in the opposite direction

; #repeat last f, F, t or T operation

, #repeat last f, F, t or T operation, but in the opposite direction

C-f #forward a (full) screen (mnemonic: "forward")

C-b #back a (full) screen (mnemonic: "back")

C-d #down a (half) screen (mnemonic: "down")

C-u #up a (half) screen (mnemonic: "up")

H #jump to top of screen (mnemonic: "high")

M #jump to middle of screen (mnemonic: "middle")

L #jump to bottom of screen (mnemonic: "low")

gg #jump to top of file (mnemonic: like more or less pagers, except plain g isn’t available so we have to use gg)

G #jump to bottom of file (mnemonic: like more or less pagers)

200G #jump to line 200

:200 #same as 200G

{ #jump to last blank line

} #jump to next blank line

[[ #jump to previous { in column 0

]] #jump to next { in column 0

][ #jump to next } in column 0

[] #jump to previous } in column 0

% $jump to matching brace (with matchit.vim you can also jump to matching HTML tags and the like)

]s #jump to next misspelled word

zg #mark a word as good, adding it to the spelling dictionary
{% endhighlight %}

## Scrolling

{% highlight vimscript %}
zz #center current cursor line within viewport

zt #scroll current cursor line to top of viewport

zb #scroll current cursor line to bottom of viewport

C#-y #scroll down a line

C-e #scroll up a line

C-d #scroll down one page

C-u #scroll up one page
{% endhighlight %}


## Autonumbering Several Lines

1. Type "1." in every line.
1. Select all of them with visual block. (`<C-v>`)
1. `g<C-a>` for ascending | `g<C-x>` for descending 

# Insert Mode

{% highlight vimscript %}
C-o #switch from insert mode to normal mode just for one normal mode command

C-w #delet to the beginning of current word

C-t #indent current line

C-d #dedent current line

C-v<tab> #insert a hard tab when it normally expands to spaces

C-r% #insert current filename
{% endhighlight %}

# Command Mode

{% highlight vimscript %}
:map # Give a list of user-defined mappings

:help index # Give a full list of mappings

:help map-witch-keys # Give a list of all unmapped keys

:helpgrep {pattern} # Search all help documents for pattern 

:earlier 5m # Go backward 5 minutes in time

:later 5m # Go forward  5 minutes in time

:setlocal spell! spelllang=en_us # Set spell checker

:set ic # Case insensitive

:set hlsearch # Highlight search

:m,n bw # Wipe m-n buffers

:bd pattern # Search a pattern in buffers to delete

:buffers # Show all buffers

:nohlsearch (:noh) # Remove currently visible search highlighting (doesn’t disable highlighting permanently)

:enew (:ene) # Open a new scratch buffer

:write # Write current buffer to a file

:read # Read into current buffer; eg: 

:read !{shell command} # Insert output of shell command into current buffer at current cursor location

:{range}d # Delete lines in {range}

:{range}y # Yank lines in {range}

:g/{pattern}/{action} # Perform action on lines matching pattern (eg. :g/a/d would delete all lines matching "a")

:v/{pattern}/{action} # Inverse of :g (performs action on non-matching lines)

:echo expand("%") # Show the current buffer PATH

:w !sudo tee % # Write to a read only file with root privileges
{% endhighlight %}

## command-line Window

To open the command-line window (showing full command history in a buffer, which you can edit, then use <CR> to run a given line’s command):

{% highlight vimscript %}
q: #for commands

q/ #for searches (or q?)
{% endhighlight %}


## Quickfix/Location List

{% highlight vimscript %}
:cclose (:ccl) #close quickfix window (:lclose and :lcl for location list)

:colder (:col) #show previous quickfix results (:lolder and :lol for location list)

:cnewer (:cnew) #show subsequent quickfix results (:lnewer and :lnew for location list)
{% endhighlight %}

# marks and jumps

When jumping to a mark, there are two variants:

with `'`, the jump is line-wise, to the first non-blank character on the line containing the mark

with `, the jump is character-wise, to the position of the mark within the line

{% highlight vimscript %}
m{letter} #create a mark at the current position

'{letter} #jump to specified mark (first non-whitespace character on line)

`{letter} #jump to specified mark (to column where mark was set)

'' #jump back to the last line jumped from

`` #jump back to the last position jumped from

`. #jump to position where last change occurred in current buffer

`[ and `] #jump to beginning/end of last changed or yanked text

`< and `> #jump to beginning/end of last visual selection

:jump #show the jump list (places you’ve jumped to with motion commands, specifically those listed at :h jump-motions)

C-o #move to older position in jump list (mnemonic: "jump out")

C-i: #move to newer position in jump list (mnemonic: "jump in")

:changes #show the changes list for the current buffer (places you’ve edited)

g; #move to older position in change list

g, #move to newer position in change list
{% endhighlight %}

# Folding

{% highlight vimscript %}
zr #decrement 'foldlevel' A.K.A. "fold less" (mnemonic: reduce)

zm #increment 'foldlevel' A.K.A. "fold more" (mnemonic: more)

zR #decrement 'foldlevel' to zero A.K.A. "unfold everything" (mnemonic: reduce)

zM #increment 'foldlevel' to maximum A.K.A> "fold everything" (mnemonic: more)

zo #open current fold

zO #open current fold recursively

zc #close current fold

zC #close current fold recursively

zv #view cursor line A.K.A. "open just enough folds to make cursor line visible" (mnemonic: view/visible)

zi #toggle value of 'foldenable' (mnemonic: invert)
{% endhighlight %}

#Visual Mode Commands

Enter using V:

{% highlight vimscript %}
gq #reformat (rewrap) selection

o #jump to opposite end of selection
{% endhighlight %}

# Visual (block) Mode Commands

Enter using <C-v>:

{% highlight vimscript %}
$A{string}<Esc> #append to each line, varying lengths (details).
{% endhighlight %}

# Mappings

{% highlight vimscript %}
CTRL-w Enter #open current item in a split.
{% endhighlight %}

## Mappings Available in Command Mode

{% highlight vimscript %}
<C-r>{register} #paste the text from the specified register into the command line (eg. to paste the last-yanked text, do <C-r>") 

<C-r>w #paste word currently under cursor
{% endhighlight %}

## Special Mappings

{% highlight vimscript %}
<C-w><CR> #open quickfix entry in a horizontal split
{% endhighlight %}

# Global Commands

{% highlight vimscript %}
:g/var[A-Z]\+[0-9]/norm_da(0P #delete around () in any line that has var"any sequence of a-z""any sequence of 0-9" pattern and paste in in the beginning of the line

:12read !"a shell command" #read the output of shell command and insert that into document after line 12(use $ for the end of document)

:g/pattern/command #run the command on every line that included the pattern (use g! or v for reverse)

:g/^\s*$/d #delete all empty lines

:g/pattern/t$ #copy every line that has the pattern in it and paste them at the end of document (use m$ for moving those lines)

:g/^/m0 #reverse the line order in document
{% endhighlight %}

# Diff

{% highlight vimscript %}
[c #jump to previous change

]c #jump to next change 

do #diff optain

dp #diff put

zo #open folded text

zc #close folded text

:diffupdate #update diffs
{% endhighlight %}

# Search

{% highlight vimscript %}
* #find word under cursor

# #find word under cursor (reverse direction)

g* #like *, but also looks for matches which are substrings of other words

g# #like #, but also looks for matches which are substrings of other words

/{pattern} #find pattern (mnemonic: like Perl/Ruby/pager etc regex syntax)

?{pattern} #find pattern (reverse direction)

n #repeat last search

N #repeat last search in opposite direction

gn #go to next match and select it visually; can be used as a motion as well (ie. cgn means "change next match")

ggn #go to first match in file

Gn #go to last match in file
{% endhighlight %}

## ranges and patterns

{% highlight vimscript %}
$ #end of the document
. #current line
^ #beginning of line
{% endhighlight %}

# plugins

{% highlight vimscript %}
coc #autocomplete

alvan/vim-closetag

neoclide/coc-pairs

tpope/vim-surround

emmet #html tags
{% endhighlight %}
